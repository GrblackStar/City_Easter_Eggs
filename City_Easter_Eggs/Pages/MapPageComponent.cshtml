@using City_Easter_Eggs.Controllers;

@inject MapsService MapService;
@inject UserService UserManager;

<html>
<head>
    <title></title>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <style type="text/css">
        html, body, #map {
            height: 100%;
            margin: 0px;
            padding: 0px
        }

        /* OPTIONS SECTION STYLING */
        .info-icon {
            position: relative;
            display: inline-block;
            cursor: pointer;
            margin-left: 5px;
        }

        .info-icon .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%; /* Position the tooltip above the icon */
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 14px;
        }

        .info-icon:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        #optionsSection div {
            margin-bottom: 10px;
        }

        #optionsSection h3 {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .large-checkbox {
            width: 18px;
            height: 18px;
            vertical-align: middle;
            margin-right: 10px;
        }

        /* TABLE STYLING */
        .table-container {
            width: 100%;
            max-height: 700px;
            overflow-y: auto;
            margin-top: 50px;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.2);
        }

        .table-responsive {
            width: 100%;
            overflow-x: auto;
        }

        #pointsTable {
            width: 100%;
            border-collapse: collapse;
            font-family: 'Arial', sans-serif;
        }


        #pointsTable thead tr {
            background-color: #404040 !important;
            color: #ffffff;
        }

        #pointsTable th, #pointsTable td {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid #ddd;
        }

        #pointsTable tr:nth-child(odd) {
            background-color: #ffffff;
        }

        #pointsTable tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        #pointsTable tr:hover {
            background-color: #f1f1f1;
            cursor: pointer;
        }

        .table-container th, .table-container td {
            max-width: 150px; /* Default max width for all columns */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .table-container .name-column {
            max-width: 300px; /* Specific max width for description column */
        }

        th {
            cursor: pointer;
            position: relative;
        }

        .sort-indicator::after {
            content: ' \25B2\25BC'; /* Up and down arrows */
            display: none;
        }

        th.asc .sort-indicator::after {
            content: ' \25B2'; /* Up arrow */
            display: inline;
        }

        th.desc .sort-indicator::after {
            content: ' \25BC'; /* Down arrow */
            display: inline;
        }

        /* th .sort-indicator::after {
            content: '';
            display: inline-block;
            margin-left: 5px;
            border: 4px solid transparent;
            border-top-color: white;
            vertical-align: middle;
        }

        th.asc .sort-indicator::after {
            border-top-color: transparent;
            border-bottom-color: white;
        }

        th.desc .sort-indicator::after {
            border-top-color: white;
        } */

        @@keyframes fadein {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @@keyframes fadeout {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }
    </style>

    <script type="module">
        const IsUserLoggedIn = "@User?.Identity!.IsAuthenticated" == 'True';
        const CurrentUserId = "@User?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value"
        window.IsUserLoggedIn = IsUserLoggedIn;

        // Request needed libraries.
        const { Map, InfoWindow } = await google.maps.importLibrary("maps");
        const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");

        let map;
        var panelPointInfo = null;
        var panelPointInfo_CurrentMarker = null;

        // https://developers.google.com/maps/documentation/javascript/advanced-markers/accessible-markers
        let panelCreatePoint = null;
        var oldMarkers = [];
        var userMarker = null;
        var watchID;
        var geoLoc;
        let lastPos = null;

        var pointsFromBackend = [];
        
        let currentOutsideCircle = null;
        let currentInnerCircle = null;

        var showInRadius = false;
        var showLikedOnly = false;
        var showSavedOnly = false;
        var showCreatedByMeOnly = false;

        let sortState = {
            name: 'none',
            likes: 'none', // Default sorted column
            distance: 'asc',
            createdOn: 'none',
            creator: 'none',
        };

        let currentSortedColumn = 'distance'; 

        function AddPointToMap(pointData) {
            var thisPoint = pointData.point;
            var pointId = thisPoint.pointId;
            const position = { lat: thisPoint.latitude, lng: thisPoint.longitude };
            const name = thisPoint.name;

            const normalEggImage = document.createElement("img");
            normalEggImage.src = "/NormalEgg.png";
            normalEggImage.width = 28;
            normalEggImage.height = 28;

            const marker = new AdvancedMarkerElement({
                map: map,
                position: position,
                title: name,
                content: normalEggImage,
            });

            // Add a click listener for each marker, and set up the info window.
            marker.addListener('click', ({ domEvent, latLng }) => {
                // Get latest data from array
                var pointData = null;
                for (let i = 0; i < pointsFromBackend.length; i++)
                {
                    var thisPoint = pointsFromBackend[i];
                    if (thisPoint.point.pointId == pointId)
                    {
                        pointData = thisPoint
                    }
                }
                if (pointData == null) return;

                var thisPoint = pointData.point;
                var likes = thisPoint.likes;
                var description = thisPoint.description;
                var markerId = thisPoint.pointId;
                var likedByUser = pointData.likedByCurrentUser;
                var favoriteByUser = pointData.favoriteByCurrentUser;
                console.dir(pointData)

                const { target } = domEvent;

                let isLikedByUser = likedByUser;
                let likeButtonListener = function () {
                    if (panelPointInfo_CurrentMarker) {
                        if (markerId == null) return;

                        // Calculate the distance between the user's current location and the marker's location in meters
                        let distance = getDistanceInMeters(lastPos, position);

                        // Determine the endpoint based on whether the point is already liked by the user
                        if (distance <= 50) {
                            // Determine the endpoint based on whether the point is already liked by the user
                            let endpoint = isLikedByUser ? '/Points/UnlikePoint' : '/Points/LikePoint';

                            fetch(endpoint, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({ markerId: markerId }),
                            })
                                .then(response => response.json())
                                .then(data => {
                                    //pointsFromBackend[pointIndex] = data
                                    for (let i = 0; i < pointsFromBackend.length; i++) {
                                        if (pointsFromBackend[i].point.pointId == pointId) {
                                            pointsFromBackend[i] = data;
                                            break;
                                        }
                                    }

                                    // Update the likes label and icon
                                    document.getElementById('likes').textContent = data.point.likes;
                                    this.classList.add('animate');
                                    setTimeout(() => {
                                        let likeButtonImage = document.querySelector('#likeButton img');
                                        likeButtonImage.src = isLikedByUser ? 'HeartIcon.png' : 'HeartedIcon.png';
                                        isLikedByUser = !isLikedByUser;
                                    }, 100);
                                    setTimeout(() => {
                                        this.classList.remove('animate');
                                    }, 200);
                                    createTable();
                                })
                                .catch((error) => {
                                    showToast('Error:' + error, 'error');
                                });
                        } else {
                            // If the distance is more than 50 meters, log a message and do not make the fetch request
                            showToast('You are too far away to like this point.', 'error');
                        }
                    }
                };

                let isFavoriteByUser = favoriteByUser;
                let favoriteButtonListener = function () {
                    if (panelPointInfo_CurrentMarker) {
                        if (markerId == null) return;
                        // Determine the endpoint based on whether the point is already saved by the user
                        let endpoint = isFavoriteByUser ? '/Points/FavoriteRemovePoint' : '/Points/FavoriteAddPoint';
                        fetch(endpoint, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ markerId: markerId }),
                        })
                            .then(response => response.json())
                            .then(data => {
                                //pointsFromBackend[pointIndex] = data
                                for (let i = 0; i < pointsFromBackend.length; i++) {
                                    if (pointsFromBackend[i].point.pointId == pointId) {
                                        pointsFromBackend[i] = data;
                                        break;
                                    }
                                }
                                // Change the like button image with animation
                                this.classList.add('animate');
                                // Change the image after the button has finished growing, than resize it
                                setTimeout(() => {
                                    let heartButtonImage = document.querySelector('#favoriteButton img');
                                    heartButtonImage.src = isFavoriteByUser ? 'BookMarkIcon.png' : 'BookMarkedIcon.png';
                                    isFavoriteByUser = !isFavoriteByUser;
                                }, 100);
                                setTimeout(() => {
                                    this.classList.remove('animate');
                                }, 200);
                            })
                            .catch((error) => {
                                showToast('Error:' + error, 'error');
                            });
                    }
                };

                let directionsButtonListener = function () {
                    openGoogleMaps(thisPoint.latitude, thisPoint.longitude);
                };

                if (isInfoWindowOpen(panelCreatePoint))
                    panelCreatePoint.close();

                if (isInfoWindowOpen(panelPointInfo))
                    panelPointInfo.close();

                panelPointInfo = new InfoWindow();
                panelPointInfo.setContent(`
                                                    <style>
                                                        #infoWindowContent {
                                                            min-width: 200px;
                                                            max-width: 400px;
                                                            max-height: 600px;
                                                            overflow: hidden;
                                                        }
                                                        #nameSection, #descriptionSection {
                                                            margin-bottom: 15px;
                                                        }
                                                        #name, #description {
                                                            margin-left: 10px;
                                                        }
                                                        #buttonSection {
                                                            margin-top: 20px;
                                                            display: flex;
                                                            justify-content: space-between;
                                                        }
                                                        #likeSection {
                                                            display: flex;
                                                        }
                                                        #likeButton, #favoriteButton {
                                                            border: none;
                                                            background: none;
                                                            padding: 0;
                                                            outline: 0;
                                                            width: 25px;
                                                            height: 25px;
                                                        }
                                                        #directionsButton {
                                                            font-size: 16px; 
                                                            margin-top: 10px;
                                                            width: 100%;
                                                            outline: none;
                                                            border: none;
                                                            box-shadow: none;
                                                        }
                                                        #directionsButton:focus {
                                                            outline: none; 
                                                            border: none;
                                                            box-shadow: none;
                                                        }
                                                        .animate {
                                                            transition: transform 0.3s;
                                                            transform: scale(1.2);
                                                        }
                                                    </style>

                                                    <div id="infoWindowContent">
                                                        <div id="nameSection">
                                                            <label for="name" class="form-label" style="font-weight: bold; font-size: 16px;">Name</label>
                                                            <div id="name">${marker.title}</div>
                                                        </div>
                                                        ${description ? `
                                                            <div id="descriptionSection">
                                                                <label for="description" class="form-label" style="font-weight: bold; font-size: 16px;">Description</label>
                                                                <div id="description">${description}</div>
                                                            </div>
                                                        ` : ''}
                                                        <div id="buttonSection">
                                                            <div id="likeSection">
                                                                <button id="likeButton" style="margin-left: 5px"><img src="${likedByUser ? 'HeartedIcon.png' : 'HeartIcon.png'}" alt="Like" style="width: 25px; height: 25px;"></button>
                                                                <label id="likes" style="font-weight: normal; font-size: 20px; margin-left: 5px; padding: 2px;">${likes}</label>
                                                            </div>
                                                            <button id="favoriteButton" style="margin-right: 5px"><img src="${favoriteByUser ? 'BookMarkedIcon.png' : 'BookMarkIcon.png'}" alt="Favorite" style="width: 25px; height: 25px;"></button>
                                                        </div>
                                                        <button id="directionsButton" type="submit" class="btn btn-lg btn-primary"> Take me there </button>
                                                    </div>
                                                `);
                panelPointInfo.open(marker.map, marker);

                panelPointInfo_CurrentMarker = marker;

                google.maps.event.addListener(panelPointInfo, 'domready', function () {
                    var likeButton = document.getElementById('likeButton');
                    var favoriteButton = document.getElementById('favoriteButton');
                    var directionsButton = document.getElementById('directionsButton');
                    if (likeButton != null) likeButton.addEventListener('click', likeButtonListener);
                    if (favoriteButton != null) favoriteButton.addEventListener('click', favoriteButtonListener);
                    if (directionsButton != null) directionsButton.addEventListener('click', directionsButtonListener);
                });
            });
            return marker;
        }

        function AddMarkerToMap(position, name) {
            const normalEggImage = document.createElement("img");
            normalEggImage.src = "/EasterEgg.png";
            normalEggImage.width = 28;
            normalEggImage.height = 28;

            const marker = new AdvancedMarkerElement({
                map: map,
                position: position,
                title: name,
                content: normalEggImage,
            });
            // Add a click listener for each marker, and set up the info window.
            marker.addListener('click', ({ domEvent, latLng }) => {
                const { target } = domEvent;

                if (isInfoWindowOpen(panelCreatePoint))
                    panelCreatePoint.close();

                if (isInfoWindowOpen(panelPointInfo))
                    panelPointInfo.close();

                panelPointInfo = new InfoWindow();
                panelPointInfo.setContent(`
                    <style>
                        #infoWindowContent {
                            min-width: 150px;
                            font-size: 16px;
                            font-weight: bold;
                        }
                    </style>
                    <div id="infoWindowContent">${marker.title}</div>`);
                panelPointInfo.open(marker.map, marker);

                panelPointInfo_CurrentMarker = marker;
            });

            return marker;
        }

        async function drawPoints() {
            // var httpGetPoints = await HttpGet("/Points/GetPoints");
            var url = `/Points/GetPoints?Longitude=${lastPos.lng}&Latitude=${lastPos.lat}&ShowInRadius=${showInRadius}`;
            var httpGetPoints = await HttpGet(url);
            pointsFromBackend = JSON.parse(httpGetPoints);

            var newMarkers = [];
            
            for (let i = 0; i < pointsFromBackend.length; i++) {
                const pointData = pointsFromBackend[i];
                const point = pointData.point;

                const isCreator = point.pointCreatorId === CurrentUserId;

                if ((showLikedOnly && pointData.likedByCurrentUser) ||
                        (showSavedOnly && pointData.favoriteByCurrentUser) ||
                        (showCreatedByMeOnly && isCreator) ||
                        (!showLikedOnly && !showSavedOnly && !showCreatedByMeOnly)) {
                    var marker = AddPointToMap(pointData);
                    newMarkers[i] = marker;
                    newMarkers[point.pointId] = marker;
                }
            }

            createTable();
            
            await new Promise((resolve) => setTimeout(resolve, 50));
            // Remove old markers after drawing new ones and swap the arrays for the next draw
            removeOldMarkers();
            oldMarkers = newMarkers;
        }

        function createTable(){
            var tableBody = document.querySelector("#pointsTable tbody");
            tableBody.innerHTML = '';

            for (let i = 0; i < pointsFromBackend.length; i++) {
                const pointData = pointsFromBackend[i];
                let point = pointData.point;
                point.distance = getDistanceOfTwoPointsInKilometers(lastPos, { lat: point.latitude, lng: point.longitude });
            }

            sortTable(currentSortedColumn, sortState[currentSortedColumn]);

            for (let i = 0; i < pointsFromBackend.length; i++) {
                const pointData = pointsFromBackend[i];
                let point = pointData.point;

                const isCreator = point.pointCreatorId === CurrentUserId;

                if ((showLikedOnly && pointData.likedByCurrentUser) ||
                    (showSavedOnly && pointData.favoriteByCurrentUser) ||
                    (showCreatedByMeOnly && isCreator) ||
                    (!showLikedOnly && !showSavedOnly && !showCreatedByMeOnly)) {

                    // Create a new row and cells for the point
                    var row = tableBody.insertRow();
                    var nameCell = row.insertCell(0);
                    var likesCell = row.insertCell(1);
                    var distanceCell = row.insertCell(2);
                    var dateCell = row.insertCell(3);
                    var creatorCell = row.insertCell(4);

                    // CSS classes
                    nameCell.classList.add('name-column');
                    creatorCell.classList.add('creator-column');
                    likesCell.classList.add('likes-column');
                    dateCell.classList.add('date-column');
                    distanceCell.classList.add('distance-column');

                    //debugger;
                    nameCell.textContent = point.name;
                    creatorCell.textContent = point.pointCreatorName;
                    likesCell.textContent = point.likes;
                    dateCell.textContent = convertTimestampToDate(point.timeStamp);

                    distanceCell.textContent = point.distance.toFixed(3);

                    row.addEventListener('click', function () {
                        if (map != null && point.latitude != null && point.longitude != null) {
                            var markerClicked = oldMarkers[point.pointId];
                            markerClicked.content.classList.add("bounce");
                            setTimeout(() => {
                                markerClicked.content.classList.remove("bounce");
                            }, 2000);

                            // center the map to the point and scroll up to the map
                            map.panTo({ lat: point.latitude, lng: point.longitude });
                            map.setZoom(80);
                            scrollToMap();
                        }
                    });
                }
            }
            updateHeaders();
        }

        function removeOldMarkers() {
            for (var i = 0; i < oldMarkers.length; i++) {
                // after filtering, the oldMarkers array will have null values
                if (oldMarkers[i]) {
                    oldMarkers[i].setMap(null);
                }
            }
            oldMarkers = [];
        }

        // used for small distance calculations, as it ignores the curvature of Earth
        function GetPosDist(pointA, pointB) {
            var a = pointA.lat - pointB.lat;
            var b = pointA.lng - pointB.lng;

            return Math.sqrt(a * a + b * b);
        }

        function scrollToMap() {
            var mapElement = document.getElementById('map');
            if (mapElement) {
                mapElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function getDistanceOfTwoPointsInKilometers(pointA, pointB) {
            let lat1 = pointA.lat;
            let lon1 = pointA.lng;
            let lat2 = pointB.lat;
            let lon2 = pointB.lng;

            // The math module contains a function named toRadians which converts from degrees to radians.
            lon1 = lon1 * Math.PI / 180;
            lon2 = lon2 * Math.PI / 180;
            lat1 = lat1 * Math.PI / 180;
            lat2 = lat2 * Math.PI / 180;

            // Haversine formula
            let dlon = lon2 - lon1;
            let dlat = lat2 - lat1;
            let a = Math.pow(Math.sin(dlat / 2), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(dlon / 2), 2);

            let c = 2 * Math.asin(Math.sqrt(a));

            // Radius of earth in kilometers. Use 3956 for miles
            let r = 6371;

            // calculate the result
            return (c * r);
        }

        function getDistanceInMeters(pointA, pointB) {
            return getDistanceOfTwoPointsInKilometers(pointA, pointB) * 1000;
        }

        function showInnerCircle(radius, position) {
            // "#4287f5"
            // #6d0cad
            currentInnerCircle = new google.maps.Circle({
                strokeColor: "#9a00ff",
                strokeOpacity: 0.7,
                strokeWeight: 3,
                fillColor: "#000000",
                fillOpacity: 0,
                map: map,
                center: position,
                radius: radius,
                clickable: false,
                zIndex: 100
            });
        }

        function drawCircle(point, radius, dir) {
            var d2r = Math.PI / 180; // degrees to radians 
            var r2d = 180 / Math.PI; // radians to degrees 
            var earthsradius = 6371 * 1000;
            var points = 128;

            // find the raidus in lat/lon 
            var rlat = (radius / earthsradius) * r2d;
            var rlng = rlat / Math.cos(point.lat * d2r);

            var extp = new Array();
            // one extra here makes sure we connect the ends
            if (dir == 1) {
                var start = 0;
                var end = points + 1
            } 
            else {
                var start = points + 1;
                var end = 0
            }
            for (var i = start;
                (dir == 1 ? i < end : i > end); i = i + dir) {
                var theta = Math.PI * (i / (points / 2));
                
                var ey = point.lng + (rlng * Math.cos(theta)); // center a + radius x * cos(theta) 
                var ex = point.lat + (rlat * Math.sin(theta)); // center b + radius y * sin(theta) 
                
                extp.push(new google.maps.LatLng(ex, ey));
            }
            return extp;
        }

        function showOutsideCircle(radius, center) {
            removeCircle(currentOutsideCircle);
            if (!showInRadius) return;
            var outerbounds = [
                new google.maps.LatLng(85, 180),
                new google.maps.LatLng(85, 90),
                new google.maps.LatLng(85, 0),
                new google.maps.LatLng(85, -90),
                new google.maps.LatLng(85, -180),
                new google.maps.LatLng(0, -180),
                new google.maps.LatLng(-85, -180),
                new google.maps.LatLng(-85, -90),
                new google.maps.LatLng(-85, 0),
                new google.maps.LatLng(-85, 90),
                new google.maps.LatLng(-85, 180),
                new google.maps.LatLng(0, 180),
                new google.maps.LatLng(85, 180)
            ];

            var circle = {
                strokeColor: '#000000',
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: '#000000',
                fillOpacity: 0.65,
                map: map,
                paths: [outerbounds, drawCircle(center, radius, -1)],
                clickable: false
            };
            // Add the circle to the map.
            currentOutsideCircle = new google.maps.Polygon(circle);
        }

        function removeCircle(currentCircle) {
            if (currentCircle) {
                currentCircle.setMap(null);
                currentCircle = null;
            }
        }

        function convertTimestampToDate(timestamp) {
            // Convert seconds to milliseconds and format the tade
            const date = new Date(timestamp * 1000);
            // 5/26/2024 5:03:09 PM format
            //return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
            const options = {
                year: 'numeric',
                month: 'short',
                day: '2-digit'
                // hour: '2-digit',
                // minute: '2-digit',
                // second: '2-digit',
                // hour12: false
            };
            return date.toLocaleString('en-US', options).replace(',', '');
        }

        function showLocation(position) {
            var latitude = position.coords.latitude;
            var longitude = position.coords.longitude;
            var pos = { lat: latitude, lng: longitude };

            if (lastPos != null) {
                var dist = GetPosDist(lastPos, pos);
                if (dist < 0.0001) return;
                console.log("Moved Distance", dist);
            }
            lastPos = pos;

            // If the user marker doesn't exist, create it.
            if (!userMarker) {
                userMarker = AddMarkerToMap(pos, "Current Location", true);
                userMarker.optimized = false;
                userMarker.zIndex = 99999999;
            }
            else {
                // If it does exist, update its position. Redraw the inner circle if the user has moved.
                createTable();
                userMarker.position = pos;
                if (showInRadius) drawPoints();
                removeCircle(currentInnerCircle);
                removeCircle(currentOutsideCircle);
                showInnerCircle(5000, pos);
                showOutsideCircle(5000, pos);
                showToast('Your current location changed', 'success');
                // if showInRadius is true, redraw the points
            }

            console.log("You are at", "Latitude : " + latitude + " Longitude: " + longitude);
        }

        async function updateLocation() {
            if (navigator.geolocation) {
                let position = await GetUserLocation();
                showLocation(position);
            } else {
                showToast('Sorry, browser does not support geolocation!', 'error');
            }
            setTimeout(updateLocation, 2000)
        }

        function errorHandler(err) {
            if (err.code == 1) {
                showToast('Error: Access is denied!', 'error');
            } else if (err.code == 2) {
                showToast('Error: Position is unavailable!', 'error');
            }
        }

        function createCenterControl(map) {
            const controlButton = document.createElement("button");
            controlButton.className = "btn btn-lg btn-primary";
            controlButton.textContent = "Back to my location";
            // remove border and focus outline
            controlButton.style.outline = "none";
            controlButton.style.border = "none";
            controlButton.style.boxShadow = "none";
            controlButton.addEventListener("click", async function () {
                if (map != null && lastPos != null) {
                    // it shouldn't get the position again, because otherwise it could get the pos wrong and update it
                    map.panTo(lastPos);
                    map.setZoom(80);
                }
            });

            return controlButton;
        }

        async function initMap() {
            // The map, centered at the current position
            var myPos = await GetUserLocation();
            var position = { lat: myPos.coords.latitude, lng: myPos.coords.longitude };
            map = new Map(document.getElementById("map"), {
                zoom: 80,
                mapId: "DEMO_MAP_ID",
                mapTypeId: google.maps.MapTypeId.SATELLITE,
                center: position,
                zoomControl: true,
                mapTypeControl: false,
                scaleControl: true,
                streetViewControl: true,
                rotateControl: false,
                fullscreenControl: false,
                gestureHandling: "greedy"
            });

            showLocation(myPos);
            drawPoints();

            map.addListener('click', function (e) {
                let distance = getDistanceInMeters(lastPos, { lat: e.latLng.lat(), lng: e.latLng.lng() });
                if (distance <= 50) {
                    const form = document.createElement('form');
                    form.id = "createPointForm";
                    form.innerHTML = `
                                                        <style>
                                                            #createPointForm {
                                                                width: 300px;
                                                            }
                                                            #createPointForm button {
                                                                padding: 7px 20px;
                                                                font-size: 14px;
                                                                height: 35px;
                                                            }
                                                            #mainText {
                                                                font-size: 16px;
                                                                padding-bottom: 10px;
                                                                font-weight: bold;
                                                            }
                                                        </style>
                                                        <input type="hidden" id="userLocationLongitude" name="UserLocationLongitude" value="${e.latLng.lng()}">
                                                        <input type="hidden" id="userLocationLatitude" name="UserLocationLatitude" value="${e.latLng.lat()}">
                                                        <div>
                                                            <label id="mainText" for="name" class="form-label">ADD A POINT</label>
                                                        </div>
                                                        <div id="createPointErrorContainer" class="text-danger mb-2" role="alert"></div>
                                                        <div class="mb-3">
                                                            <label for="name" class="form-label">Location name</label>
                                                            <span>
                                                                <label class="text-danger" style="font-size: 12px">* Required</label>
                                                            </span>
                                                            <input type="text" id="name" name="Name" class="form-control" required placeholder="Name">
                                                        </div>
                                                        <div class="mb-3">
                                                            <label for="description" class="form-label">Description</label>
                                                            <textarea id="description" name="Description" class="form-control" placeholder="Description" rows="5"></textarea>
                                                        </div>
                                                        <div class="mb-3 d-flex justify-content-between">
                                                            <button id="createPointSubmit" type="submit" class="btn btn-lg btn-primary">Create Point</button>
                                                            <button id="createPointCancel" type="button" class="btn btn-secondary" style="padding-left: 15px; padding-right: 15px">Cancel</button>
                                                        </div>
                                                    `;

                    form.addEventListener('submit', function (event) {
                        event.preventDefault();

                        var formData = new FormData(form);
                        var object = {};
                        formData.forEach((value, key) => object[key] = value);
                        var json = JSON.stringify(object);

                        fetch('/Points/CreatePoint', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: json,
                        }).then(response => {
                            if (response.ok) {
                                showToast('You have created a point.', 'success');
                                panelCreatePoint.close();
                                drawPoints();
                            } else {
                                response.json().then(x => {
                                    var errorContainer = $("#createPointForm").find("#createPointErrorContainer")
                                    errorContainer.empty()

                                    var errors = x.errors
                                    var errorKeys = Object.keys(errors);

                                    for (var i = 0; i < errorKeys.length; i++) {
                                        var thisProp = errorKeys[i];
                                        var array = errors[thisProp];
                                        for (var ii = 0; ii < array.length; ii++) {
                                            errorContainer.append($('<div>', {
                                                text: array[ii]
                                            }));
                                        }
                                    }
                                });
                            }
                        });
                    });

                    if (isInfoWindowOpen(panelPointInfo) || isInfoWindowOpen(panelCreatePoint)) {
                        if (isInfoWindowOpen(panelPointInfo))
                            panelPointInfo.close();
                        if (isInfoWindowOpen(panelCreatePoint))
                            panelCreatePoint.close();
                        return;
                    }

                    // If an info window already exists, reuse it
                    if (isInfoWindowOpen(panelCreatePoint)) {
                    }
                    else {
                        // Create a new info window with the form as its content
                        panelCreatePoint = new InfoWindow({
                            content: form
                        });
                        panelCreatePoint.open(map);

                        // Event listener to the close button of the info window to close it.
                        // Using "domready" ensures that the dom is loaded and can find the component
                        google.maps.event.addListener(panelCreatePoint, 'domready', function () {
                            var cancelButton = document.getElementById('createPointCancel');
                            if (!cancelButton) return;
                            cancelButton.addEventListener('click', function () {
                                panelCreatePoint.close();
                            });
                        });
                    }

                    // Open the info window at the clicked location
                    panelCreatePoint.setPosition(e.latLng);
                } else {
                    showToast('You are too far away to create a point here.', 'error');
                    if (isInfoWindowOpen(panelPointInfo) || isInfoWindowOpen(panelCreatePoint)) {
                        if (isInfoWindowOpen(panelPointInfo))
                            panelPointInfo.close();
                        if (isInfoWindowOpen(panelCreatePoint))
                            panelCreatePoint.close();
                        return;
                    }
                }
            });

            const centerControlDiv = document.createElement("div");
            const centerControl = createCenterControl(map);

            centerControlDiv.appendChild(centerControl);
            map.controls[google.maps.ControlPosition.TOP_LEFT].push(centerControlDiv);
        }

        function showToast(message, type) {
            // Check if a toast already exists, so it doesn't open multiple at the same time
            if (document.querySelector('.toast')) {
                return;
            }

            // Create toast container if it doesn't exist
            let toastContainer = document.getElementById('toastContainer');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toastContainer';
                toastContainer.style.position = 'fixed';
                toastContainer.style.top = '20px';
                toastContainer.style.left = '50%';
                toastContainer.style.transform = 'translateX(-50%)';
                toastContainer.style.zIndex = '9999';
                toastContainer.style.display = 'flex';
                toastContainer.style.justifyContent = 'center';
                toastContainer.style.alignItems = 'center';
                toastContainer.style.pointerEvents = 'none';
                document.body.appendChild(toastContainer);
            }

            // Create toast
            const toast = document.createElement('div');
            toast.className = 'toast'; // for easy selection
            toast.style.background = type === 'success' ? '#689F38' : '#CF1A2B';
            toast.style.color = 'white';
            toast.style.padding = '5px';
            toast.style.minWidth = '300px';
            toast.style.borderRadius = '7px';
            toast.style.boxShadow = '0 0.125rem 0.25rem grey';
            toast.style.fontSize = '14px';
            toast.style.display = 'flex';
            toast.style.justifyContent = 'space-between';
            toast.style.alignItems = 'center';
            toast.style.animation = 'fadein 0.5s, fadeout 0.5s 2.5s';

            // Icon
            const icon = document.createElement('img');
            icon.src = type === 'success' ? 'CheckIcon.svg' : 'CloseIcon.svg';
            icon.style.width = '14px';
            icon.style.height = '14px';
            icon.style.marginRight = '10px';
            icon.style.marginLeft = '7px';
            icon.style.filter = 'invert(1)'; // Makes the icon white
            toast.appendChild(icon);

            // Message
            const toastMessage = document.createElement('span');
            toastMessage.textContent = message;
            toastMessage.style.whiteSpace = 'nowrap';
            toast.appendChild(toastMessage);

            // Dismiss button
            const dismissButton = document.createElement('button');
            dismissButton.textContent = 'Dismiss';
            dismissButton.style.background = 'transparent';
            dismissButton.style.border = 'none';
            dismissButton.style.fontSize = '12px';
            dismissButton.style.marginRight = '7px';
            dismissButton.style.color = 'white';
            dismissButton.style.textDecoration = 'underline';
            dismissButton.style.cursor = 'pointer';
            dismissButton.style.pointerEvents = 'auto';
            dismissButton.addEventListener('click', () => {
                toastContainer.removeChild(toast);
                if (!toastContainer.firstChild) {
                    toastContainer.remove();
                }
            });
            toast.appendChild(dismissButton);

            // Add toast to container
            toastContainer.appendChild(toast);
            toast.style.width = `${toastMessage.offsetWidth + 120}px`;

            // Remove toast after 2.95 seconds -> a little before it fades out
            setTimeout(() => {
                if (toast.parentNode === toastContainer) {
                    toastContainer.removeChild(toast);
                    if (!toastContainer.firstChild) {
                        toastContainer.remove();
                    }
                }
            }, 2950);
        }

        window.toggleSort = function(column) {
            const currentState = sortState[column];
            const nextState = currentState === 'asc' ? 'desc' : 'asc';

            // Unsort previous column
            if (currentSortedColumn && currentSortedColumn !== column) {
                sortState[currentSortedColumn] = 'none';
            }

            sortState[column] = nextState;
            currentSortedColumn = column;

            createTable();
        }

        function sortTable(column, order) {
            pointsFromBackend.sort((a, b) => {
                let valA, valB;
                if (column === 'createdOn') {
                    valA = new Date(a.point.timeStamp * 1000);
                    valB = new Date(b.point.timeStamp * 1000);
                } else if (typeof a.point[column] === 'number') {
                    valA = a.point[column];
                    valB = b.point[column];
                } else {
                    valA = String(a.point[column]).toLowerCase();
                    valB = String(b.point[column]).toLowerCase();
                }

                if (order === 'asc') {
                    return valA > valB ? 1 : -1;
                } else if (order === 'desc') {
                    return valA < valB ? 1 : -1;
                } else {
                    return 0;
                }
            });
        }

        function updateHeaders() {
            const headers = document.querySelectorAll('#pointsTable th');
            headers.forEach(header => {
                const column = header.getAttribute('data-column');
                const state = sortState[column];
                header.classList.remove('asc', 'desc');
                if (state === 'asc') {
                    header.classList.add('asc');
                } else if (state === 'desc') {
                    header.classList.add('desc');
                }
            });
        }

        async function updatePoints() {
            // this gets the points more frequently -> 5 minutes
            await drawPoints();
            setTimeout(updatePoints, 300000);
        }

        function openGoogleMaps(lat, lng) {
            const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
            // opens a new tab: window.open(googleMapsUrl, '_blank');
            // directly navigates from the current tab
            window.location.href = googleMapsUrl;
        }

        window.updateOnOpionsChange = function(radius, liked, saved, created) {
            showInRadius = radius;
            showLikedOnly = liked;
            showSavedOnly = saved;
            showCreatedByMeOnly = created;

            showOutsideCircle(5000, lastPos);
            drawPoints();
        }

        await initMap();
        await updateLocation();
        showInnerCircle(5000, lastPos);
        await updatePoints();
    </script>
</head>
<body>
    <div style="height: 700px" id="map"></div>
    
    <div id="optionsSection" style="margin-top: 50px;">
        <h3>Options</h3>
        <div>
            <input type="checkbox" id="toggleShowInRadius" onclick="toggleOptions()" class="large-checkbox"> Show points in 5 km radius
            <span class="info-icon">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="8" cy="8" r="7.5" stroke="black"/>
                    <text x="8" y="12" text-anchor="middle" font-size="10" fill="black">i</text>
                </svg>
                <span class="tooltip-text">This option will display points within a 5 km radius from the center of the map.</span>
            </span>
        </div>
        <div>
            <input type="checkbox" id="toggleShowLikedByMe" onclick="toggleOptions()" class="large-checkbox"> Show liked by me
            <span class="info-icon">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="8" cy="8" r="7.5" stroke="black"/>
                    <text x="8" y="12" text-anchor="middle" font-size="10" fill="black">i</text>
                </svg>
                <span class="tooltip-text">This option will display points that you have liked.</span>
            </span>
        </div>
        <div>
            <input type="checkbox" id="toggleShowSaved" onclick="toggleOptions()" class="large-checkbox"> Show saved
            <span class="info-icon">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="8" cy="8" r="7.5" stroke="black"/>
                    <text x="8" y="12" text-anchor="middle" font-size="10" fill="black">i</text>
                </svg>
                <span class="tooltip-text">This option will display points that you have saved.</span>
            </span>
        </div>
        <div>
            <input type="checkbox" id="toggleShowCreatedByMe" onclick="toggleOptions()" class="large-checkbox"> Show created by me
            <span class="info-icon">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="8" cy="8" r="7.5" stroke="black"/>
                    <text x="8" y="12" text-anchor="middle" font-size="10" fill="black">i</text>
                </svg>
                <span class="tooltip-text">This option will display points that you have created.</span>
            </span>
        </div>
    </div>

    <div class="table-container">
        <div class="table-responsive">
            <table id="pointsTable">
                <thead>
                    <tr>
                        <th data-column="name" onclick="toggleSort('name')">Name <span class="sort-indicator"></span></th>
                        <th data-column="likes" onclick="toggleSort('likes')">Likes <span class="sort-indicator"></span></th>
                        <th data-column="distance" onclick="toggleSort('distance')">Distance (km) <span class="sort-indicator"></span></th>
                        <th data-column="createdOn" onclick="toggleSort('createdOn')">Created On <span class="sort-indicator"></span></th>
                        <th data-column="creator" onclick="toggleSort('creator')">Creator <span class="sort-indicator"></span></th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Rows are added dynamically -->
                </tbody>
            </table>
        </div>
    </div>



    <script>
        const apiKey = "@MapService.GetAPIKey()";
        (g => { var h, a, k, p = "The Google Maps JavaScript API", c = "google", l = "importLibrary", q = "__ib__", m = document, b = window; b = b[c] || (b[c] = {}); var d = b.maps || (b.maps = {}), r = new Set, e = new URLSearchParams, u = () => h || (h = new Promise(async (f, n) => { await (a = m.createElement("script")); e.set("libraries", [...r] + ""); for (k in g) e.set(k.replace(/[A-Z]/g, t => "_" + t[0].toLowerCase()), g[k]); e.set("callback", c + ".maps." + q); a.src = `https://maps.${c}apis.com/maps/api/js?` + e; d[q] = f; a.onerror = () => h = n(Error(p + " could not load.")); a.nonce = m.querySelector("script[nonce]")?.nonce || ""; m.head.append(a) })); d[l] ? console.warn(p + " only loads once. Ignoring:", g) : d[l] = (f, ...n) => r.add(f) && u().then(() => d[l](f, ...n)) })
            ({ key: apiKey, v: "weekly" });

        function isInfoWindowOpen(infoWindow) {
            if (!infoWindow) return false;
            var map = infoWindow.getMap();
            return (map !== null && typeof map !== "undefined");
        }

        function toggleOptions() {
            window.updateOnOpionsChange(
                document.getElementById('toggleShowInRadius').checked,
                document.getElementById('toggleShowLikedByMe').checked,
                document.getElementById('toggleShowSaved').checked,
                document.getElementById('toggleShowCreatedByMe').checked,
                );
        }

        function toggleSort(column) {
            window.toggleSort(column);
        }
        
        // tooltip position strategy
        document.addEventListener('DOMContentLoaded', function () {
            const infoIcon = document.querySelector('.info-icon');
            const tooltip = infoIcon.querySelector('.tooltip-text');
            infoIcon.addEventListener('mouseover', function () {
                const rect = tooltip.getBoundingClientRect();
                const isVisible = (rect.top >= 0) && (rect.left >= 0) && (rect.bottom <= window.innerHeight) && (rect.right <= window.innerWidth);

                if (!isVisible) {
                    tooltip.style.bottom = 'auto';
                    tooltip.style.top = '125%';
                } else {
                    tooltip.style.bottom = '125%';
                    tooltip.style.top = 'auto';
                }
            });
        });
    </script>
</body>
</html>